\chapter{El caso infinito}
\label{chap:inf}
\noindent
Sea $\vec{p} \in \R^n$ un vector esencialmente entero y recordemos de la definición
\ref{theory:def:rational} que tiene un único múltiplo coprimo $\vec{q} \in \Z^n$. Es decir, existe
un único escalar $m \in \R$ que satisface tres cosas: $\vec{p} = m\vec{q}$, las entradas $q_1,
\ldots, q_n$ son coprimas, y la primera entrada no nula $q_i$ es positiva. Supondremos, sin pérdida
de generalidad, que $m$ es positivo.

Retomemos el entero $\eta \in \Z$ del lema \ref{phase-1:lemma:eta} que parametriza la primera capa
entera que satisface el presupuesto \eqref{theory:constraint:budget}. A causa del teorema
\ref{theory:th:feasibility}, sabemos que si $q_i < 0$ para alguna $i \in \braces{1, \ldots, n}$,
entonces la $\eta$-ésima capa entera contiene un número infinito de puntos factibles. No es difíci
ver, a través del lema \ref{theory:lemma:utility}, que estos puntos factibles también son soluciones
óptimas.

\begin{corollary}
	\label{cor:inf:obj}
	Supongamos que $q_i < 0$ para algún $i \in \braces{1, \ldots, n}$. Entonces el valor óptimo del
	programa lineal entero (\ref{theory:formulation}) es $m\eta$. Además, si $m$ es positivo,
	tenemos que $\eta$ es el múltiplo de $m$ más grande que satisface $m\eta \leq u$, donde $u$ es
	el lado derecho de la restricción presupuestaria \eqref{theory:constraint:budget}.
\end{corollary}
\begin{proof}
	Por hipótesis, una entrada de $\vec{q}$ es negativa. Del teorema
	\ref{theory:th:feasibility} sabemos que existen una infinidad de soluciones en la $\eta$-ésima
	capa entera, así que sea $\vec{x}^*$ una de ellas. Por el lema \ref{theory:lemma:utility} se
	sigue que $\vec{q}^T\vec{x}^* = \eta$, pero $\vec{p} = m\vec{q}$ por la definición
	\ref{theory:def:rational}, por lo que obtenemos $\vec{p}^T\vec{x}^* = m\vec{q}^T\vec{x}^* =
	m\eta$.

	Ahora bien, supongamos $m$ es positivo pero que $\eta$ no es el múltiplo más grande de $m$ que
	satisface $m\eta \leq u$. Supongamos que $\xi \in \Z$ satisface $m\xi \leq u$ y también $\eta <
	\xi$. Por el lema \ref{phase-1:lemma:eta} tenemos $\eta = \floor{u/m}$. Luego,
	\begin{equation*}
		m\eta = m\left\lfloor \frac{u}{m} \right\rfloor < m\xi \leq u
		\implies \left\lfloor \frac{u}{m} \right\rfloor < \xi \leq \frac{u}{m},
	\end{equation*}
	pero esto contradice las propiedades de la función piso. Finalmente, por hipótesis tenemos que
	$m$ es positivo y por lo tanto $\eta$ debe ser el múltiplo más grande de $m$ que satisface
	$m\eta \leq u$.
\end{proof}

\begin{observation}
	Para ilustrar la conveniencia de restringir $m$ a que sea positivo, consideremos el caso cuando
	$m < 0$. Del lema \ref{phase-1:lemma:eta} tenemos que $\eta \coloneq \lceil u/m \rceil$
	parametriza también la primera capa entera que satisface el presupuesto, pues ahora tenemos de
	la restricción \eqref{theory:constraint:budget} que $\vec{p}^T\vec{x} \leq u$ si y solo si
	$\vec{q}^T\vec{x} \geq u/m$. Se sigue cumpliendo que el valor óptimo del problema
	\eqref{theory:formulation} es $m\eta$. Sin embargo, $\eta$ ahora es el múltiplo más pequeño de $m$
	que satisface $m\eta \geq u$.
\end{observation}

Puesto que somos capaces de decidir si un escalar $u^*$ es el valor óptimo del problema
\eqref{theory:formulation}, nos preguntamos ahora cómo obtener la solución óptima.

Por hipótesis de este capítulo, el vector coprimo $\vec{q}$ tiene al menos una entrada negativa. Del
teorema \ref{theory:th:feasibility}, sabemos que las infinitas soluciones de
\eqref{theory:formulation} se encuentran en la $\eta$-ésima capa entera. Luego, del lema
\ref{theory:lemma:utility} tenemos que estas soluciones satisfacen la ecuación lineal diofantina
$\vec{q}^T\vec{x} = \eta$.

Supongamos, por el momento, que $\vec{q}$ no tiene entradas nulas. Podemos permutar las entradas de
$\vec{q}$ sin afectar la el problema \eqref{theory:formulation}. En efecto, toda solución $\vec{x}
\in \Z^n$ de \eqref{theory:formulation} es no negativa y satisface $\vec{q}^T\vec{x} = \eta$. Sea $P
\in \Z^{n \times n}$ una matriz de permutación. Observemos que $\vec{x}$ es no negativo si y solo si
$P\vec{x}$ es no negativo. Además,
\begin{equation*}
	\eta = \vec{q}^T\vec{x} = \vec{q}^TP^TP\vec{x} = (P\vec{q})^T(P\vec{x}).
\end{equation*}
Por lo que podemos encontrar una solución entera no negativa $\vec{x}$ de la ecuación lineal
diofantina $(P\vec{q})^T\vec{x} = \eta$ y entonces $P\vec{x}$ es solución de
\eqref{theory:formulation}.

% \begin{observation}
% 	Si $\vec{q} \in \Z^n$ es el múltiplo coprimo de un vector esencialmente entero , entonces $P\vec{q}$ no necesariamente lo es, ya que
% 	posiblemente $(P\vec{q})_1 < 0$. Esto no constituye un problema, pues la construcción de soluciones
% 	en la sección \ref{subsec:dioph-eq} requiere que las entradas del vector sean coprimas y no hace
% 	suposiciones sobre sus signos.
% \end{observation}

En particular podemos suponer, sin pérdida de generalidad, que las entradas de  $\vec{q}$ satisfacen
$q_{n-1} < 0 < q_n$. Como $\vec{q}$ no tiene entradas nulas, de la
definición \ref{theory:def:rational} sabemos que $q_1$ es positivo y, por suposición de este capítulo,
alguna entrada $q_j$ es negativa, así que podemos permutar estas entradas con las de $q_n$ y
$q_{n-1}$, respectivamente.

De la proposición \ref{prop:xint} sabemos que el conjunto de soluciones enteras de la ecuación
lineal diofantina $\vec{q}^T\vec{x} = \eta$ es $\braces{\eta\vec{\nu} + M\vec{t} \vcentcolon \vec{t}
\in \Z^{n-1}}$. Así pues, basta encontrar condiciones suficientes en $\vec{t}$ para asegurar la no
negatividad de la solución $\vec{x} \coloneq \eta\vec{\nu} + M\vec{t}$.

Para que las primeras $n - 2$ entradas de $\vec{x}$ sean no negativas, debe ser el caso que $t_i \in
\Z$ satisfaga \eqref{eq:param-lb} para todo $1 \leq i \leq n - 2$. Recuperamos de
\eqref{eq:last-solution} que las últimas dos entradas de $\vec{x}$ son
\begin{equation*}
	\begin{cases}
		x_{n-1} = \omega_{n-1}x_{n-1}' + \frac{q_n}{\prod_{j=1}^{n-1}g_j}t_{n-1}, \\
		x_n = \omega_{n-1}x_n' - \frac{q_{n-1}}{\prod_{j=1}^{n-1}g_j}t_{n-1},
	\end{cases}
\end{equation*}
donde los enteros $g_i$ están definidos por \eqref{dummy:next-g} con $g_1 = 1$, $\omega_{n-1}$ está
definida a través de la relación de recurrencia \eqref{eq:omega-recurrence} con condición inicial
$\omega_1 = \eta$, y $x_{n-1}', x_n'$ son coeficientes de Bézout que satisfacen
\eqref{eq:last-equation-bez}. Definamos, por conveniencia,
\begin{equation}
	\label{eq:lr-bounds}
	b_1 \coloneq -\frac{\omega_{n-1}x_{n-1}'}{q_n} \cdot \prod_{j=1}^{n-1}g_j, \quad
	b_2 \coloneq \frac{\omega_{n-1}x_{n}'}{q_{n-1}} \cdot \prod_{j=1}^{n-1}g_j.
\end{equation}
Puesto que $q_{n-1} < 0 < q_n$, podemos despejar $t_{n-1}$ de las dos últimas soluciones de
\eqref{eq:last-solution} y reproducidas aquí por conveniencia,
\begin{equation*}
	\begin{cases}
		x_{n-1} = \omega_{n-1}x_{n-1}' + \frac{q_n}{\prod_{j=1}^{n-1}g_j}t_{n-1}, \\
		x_n = \omega_{n-1}x_n' - \frac{q_{n-1}}{\prod_{j=1}^{n-1}g_j}t_{n-1},
	\end{cases}
\end{equation*}
encontramos que las últimas dos entradas de $\vec{x}$ son no negativas si y solo si $t_{n-1}$ satisface
\begin{equation}
	\label{eq:feasible-param:collapsed}
	t_{n-1} \geq \ceil{\max\lbrace b_1, b_2 \rbrace}.
\end{equation}

El siguiente lema fortalece nuestros resultados al generalizarlo para todo lado derecho de
\eqref{eq:dioph}.
\begin{lemma}
	\label{lemma:t-existence}
	Sea $\vec{p} \in \R$ un vector esencialmente entero, y supongamos que su múltiplo coprimo
	$\vec{q} \in \Z^n$ tiene entradas no nulas y al menos una de ellas es negativa. Entonces la
	ecuación lineal diofantina \eqref{eq:dioph} tiene una infinidad de soluciones enteras no
	negativas.
\end{lemma}
\begin{proof}
	Supongamos, sin pérdida de generalidad, que $q_{n-1} < 0 < q_n$. Sea $\vec{t} \in \Z^{n-1}$ tal
	que
	\begin{equation*}
		t_i \geq \begin{cases}
			\ceil{-\frac{\omega_ix_i'}{g_{i + 1}}}, & i < n - 1, \\[0.5em]
			\ceil{\max\lbrace b_1, b_2 \rbrace}, & i = n - 1,
		\end{cases}
	\end{equation*}
	y sea
	\begin{equation*}
		\vec{x} \coloneq k\vec{\nu} + M\vec{t},
	\end{equation*}
	donde recuperamos $\vec{\nu}$ y $M$ de \eqref{eq:vec-omega} y \eqref{eq:mat-T}, respectivamente.
	De la proposición \ref{prop:xint}, así como de \eqref{eq:param-lb} y
	\eqref{eq:feasible-param:collapsed}, se sigue que $\vec{x}$ es entero y no negativo. Finalmente,
	de los lemas \ref{lemma:iso1} y \ref{lemma:iso2} encontramos que
	\begin{equation*}
		\vec{q}^T\vec{x} = k\vec{q}^T\vec{\nu} + \vec{q}^TM = k,
	\end{equation*}
	por lo que $\vec{x}$ es solución de \eqref{eq:dioph}.
\end{proof}

En la práctica es mejor usar la relación de recurrencia \eqref{eq:recurrence} y ``construir'' las
entradas $x_i$ al mismo tiempo que definimos $t_i$ de manera que satisfaga \eqref{eq:param-lb} y
\eqref{eq:feasible-param:collapsed}. Si procedemos de esta forma no tenemos que encontrar primero
$\vec{\nu}$ y $M$, determinar $\vec{t}$ y luego recuperar $\vec{x}$.

El algoritmo \ref{algo:inf} (pág.~\pageref{algo:inf}) muestra aquel procedimiento constructivo.
Para ello, suponemos la existencia de una subrutina \texttt{Bezout} que, como su nombre lo indica,
calcula los coeficientes de Bézout entre dos enteros. Reiteramos, así como lo hicimos en la
sección \ref{section:number-theory}, que estos coeficientes se pueden calcular por medio del
algoritmo extendido de Euclides.

\begin{algorithm}[ht]
	\LinesNumbered
	\DontPrintSemicolon
	\SetKwProg{Fn}{Fn}{\string:}{}
	\SetKwFunction{Bezout}{Bezout}
	\SetKwFunction{NonNegativeIntSol}{NonNegativeIntSolInf}
		\KwData{\\
			$\vec{q} \in \Z^n$ con entradas coprimas no nulas y tal que $q_{n-1} < 0 < q_n$. \\
			$\eta \in \Z_{\geq 0}$.
			}
		\KwResult{\\
			$\vec{x} \in \Z^n_{\geq \vec{0}}$ tal que $\vec{q}^T\vec{x} = \eta$.
		}
		\Begin{
			$\vec{x} \leftarrow \vec{0}$\;
			$\omega_1 \leftarrow \eta$\;
			$p \leftarrow 1$\;
			\For{$i \leftarrow 1$ \KwTo $n - 2$\label{alg:def:inf:loop}}{
				$g_{i+1} \leftarrow \gcd{q_{i+1} / p, \ldots, q_n / p}$\quad\tcp*[h]{ecuación
				\eqref{dummy:next-g}}\; \label{alg:def:inf:g}
				$x_i', \omega_{i+1}' \leftarrow$ \Bezout{$q_i / p$, $g_{i+1}$}\; \label{alg:def:inf:bez}
				$t_i \leftarrow \ceil{-\omega_i x_i' / g_{i+1}}$\quad\tcp*[h]{ecuación
				\eqref{eq:param-lb}}\; \label{alg:def:inf:t}
				\tcp*[h]{ecuación \eqref{eq:recurrence}}\;
				$x_i \leftarrow \omega_i x_i' + g_{i+1}t_i$\; \label{alg:def:inf:x}
				$\omega_{i+1} \leftarrow \omega_i \omega_{i+1}' - q_i t_i / p$\; \label{alg:def:inf:w}
				\tcp*[h]{actualizar producto}\;
				$p \leftarrow pg_{i+1}$\;
			}

			$x_{n-1}', x_n' \leftarrow$ \Bezout{$q_{n-1} / p$, $q_n / p$}\; \label{alg:def:inf:lastw}
			\tcp*[h]{ecuación \eqref{eq:lr-bounds}}\;
			$b_1 \leftarrow -\omega_{n-1} x_{n-1}' \cdot p/ q_n$\;
			$b_2 \leftarrow \omega_{n-1} x_n' \cdot p/ q_{n-1}$\;
			$t_{n-1} \leftarrow \ceil{\max\lbrace b_1, b_2\rbrace}$\quad\tcp*[h]{ecuación
			\eqref{eq:feasible-param:collapsed}}\;
			\tcp*[h]{ecuación \eqref{eq:last-solution}}\;
			$x_{n-1} \leftarrow \omega_{n-1}x_{n-1}' + q_nt_{n-1} / p$\;
			$x_{n} \leftarrow \omega_{n-1}x_{n}' - q_{n-1}t_{n-1} / p$\;

			\Return{$\vec{x}$}\;
		}
	\caption{\texttt{NonNegativeIntSolInf}}
	\label{algo:inf}
\end{algorithm}

\begin{lemma}
	\label{lemma:alg:inf:correct}
	El algoritmo \ref{algo:inf} en la página \pageref{algo:inf} es correcto.
\end{lemma}
\begin{proof}
	Basta observar que el algoritmo sigue la construcción recursiva de la sección
	\ref{subsec:dioph-eq}, donde escogemos las variables libres $t_i$ como lo indican
	\eqref{eq:param-lb} y \eqref{eq:feasible-param:collapsed} para asegurar que $\vec{x} \in \Z^n$
	sea no negativo.
\end{proof}

Ahora bien, supongamos que $\vec{q}$ tiene entradas nulas. Sea
\begin{equation*}
	I^\circ \coloneq \braces{i \vcentcolon q_i = 0},
\end{equation*}
y también definamos el vector $\tvec{q}$ cuyas entradas son las entradas no nulas de $\vec{q}$.
Supongamos que la penúltima entrada de $\tvec{q}$ es negativa y que su última entrada es positiva. A
causa del lema anterior, el algoritmo \ref{algo:inf} encuentra un vector $\tvec{x}$ entero no
negativo que satisface $\tvec{q}^T\tvec{x} = \eta$. Luego, encontramos que el vector $\vec{x}$ dado
por
\begin{equation*}
	x_i \coloneq
	\begin{cases}
		\tilde{x}_i, & i \not \in I^\circ, \\
		0, & i \in I^\circ,
	\end{cases}
\end{equation*}
es entero, no negativo, y también satisface $\vec{q}^T\vec{x} = \eta$.

El algoritmo \ref{algo:inf:ext} (pág.~\pageref{algo:inf:ext}) extiende el algoritmo \ref{algo:inf}
en el sentido que incorpora esta forma de manejar las entradas nulas de $\vec{q}$. Además, modifica
el vector $\tvec{q}$ de manera que aseguramos que su penúltima entrada es negativa y su última
entrada es positiva, por lo que podemos deshacernos de este supuesto. Suponemos la existencia de las
subrutinas \texttt{length} y \texttt{swap} (véase capítulos 1 y 2 de \cite{knuth1}), las cuales
determinan la dimensión de un vector $\vec{q}$ y permutan dos de sus entradas, respectivamente.

\begin{algorithm}[ht]
	\LinesNumbered
	\DontPrintSemicolon
	\SetKwProg{Fn}{Fn}{\string:}{}
	\SetKwFunction{swap}{swap}
	\SetKwFunction{NonNegativeIntSol}{NonNegativeIntSolInf}
	\SetKwFunction{FindNegEntry}{FindNegEntry}
	\SetKwFunction{length}{length}
	\SetKwFunction{Dioph}{Dioph}
		\KwData{\\
			$\vec{q} \in \Z^n$ coprimo con al menos una entrada negativa. \\
			$\eta \in \Z_{\geq 0}$.
			}
		\KwResult{\\
			$\vec{x} \in \Z^n_{\geq \vec{0}}$ tal que $\vec{q}^T\vec{x} = \eta$.
		}
		$\vec{x} \leftarrow \vec{0}$\;
		$\vec{\sigma} \leftarrow \left(i \colon q_i \neq 0\right)$\;
		$\tvec{q} \leftarrow \left( q_i \colon q_i \neq 0 \right)$\;
		\label{alg:def:inf:tilde-q}

		$m \leftarrow$ \length{$\tvec{q}$}\; \label{alg:subr:length}
		\swap{$\tvec{q}$, $1$, $m$}\quad\tcp*[h]{$\tvec{q}_m > 0$}\; \label{alg:subr:swap1}

		\For{$i \leftarrow 1$ \KwTo $m - 1$}{ \label{alg:inf:loop}
			\If{$\tilde{q}_i < 0$}{
				$j \leftarrow i$\;
				ir a la línea \ref{alg:subr:swap3}\;
			}
		}
		\swap{$\tvec{q}$, $j$, $m - 1$}\quad\tcp*[h]{$\tvec{q}_{m-1} < 0$}\; \label{alg:subr:swap3}
		$\tvec{x} \leftarrow$ \NonNegativeIntSol{$\tvec{q}$, $\eta$}\quad\tcp*[h]{algoritmo
		\ref{algo:inf}}\;
		\swap{$\tvec{x}$, $j$, $m - 1$}\; \label{alg:subr:swap2}
		\swap{$\tvec{x}$, $1$, $m$}\;

		\For{$i \leftarrow 1$ \KwTo $m$}{ \label{alg:inf:loop2}
			$x_{\sigma_i} \leftarrow \tilde{x}_i$\;
		}
		\Return{$\vec{x}$}
	\caption{\texttt{Dioph}}
	\label{algo:inf:ext}
\end{algorithm}

\begin{theorem}
	\label{th:alg:inf}
	El algoritmo \ref{algo:inf:ext} en la página \pageref{algo:inf:ext} es correcto.
\end{theorem}
\begin{proof}
	Primero mostramos que el vector $\tvec{q}$ satisface las hipótesis del algoritmo
	\ref{algo:inf}. Por definición, en la línea \ref{alg:def:inf:tilde-q}, tenemos que ninguna
	entrada de $\tvec{q}$ es nula.

	Recordemos de la definición \ref{theory:def:rational} que, como $\vec{q}$ es el múltiplo coprimo
	de un vector esencialmente entero $\vec{p}$, su primera entrada no nula es positiva. Así, es
	cierto que $\tilde{q}_1 > 0$. A partir de la transposición en la línea \ref{alg:subr:swap1}
	encontramos que $\tilde{q}_m > 0$.

	Del ciclo que comienza en la línea \ref{alg:inf:loop} recuperamos el primer índice $j$ tal que
	$\tilde{q}_j < 0$ y lo transponemos con la $(m - 1)$-ésima entrada de $\tvec{q}$ en la línea
	\ref{alg:subr:swap3}, de manera que obtenemos $\tilde{q}_{m-1} < 0$.

	Con los tres puntos anteriores, encontramos que el vector $\tvec{q}$ satisface las
	hipótesis del algoritmo \ref{algo:inf} y por lo tanto el vector $\tvec{x}$ es no negativo
	y satisface la ecuación lineal diofantina $\tvec{q}^T\tvec{x} = \eta$.

	Las siguientes dos líneas se encargan de invertir las transposiciones hechas previamente.
	Finalmente, en el ciclo que comienza en la línea \ref{alg:inf:loop2} insertamos en $\vec{x}$ los
	valores de $\tvec{x}$ donde las entradas de $\vec{q}$ son no nulas. En otro caso, donde las
	entradas de $\vec{q}$ son nulas, podemos escoger cualquier no negativo para las entradas
	correspondientes de $\vec{x}$, entonces dejamos que estas entradas sean
	cero. Así pues, el vector $\vec{x} \in \Z^n$ es no negativo y también satisface
	\begin{equation*}
		\vec{q}^T\vec{x} = \sum_{i = 1}^{n}q_ix_i
		% = \sum_{i = 1}^{m}q_{\sigma_i}x_{\sigma_i}
		= \sum_{i = 1}^{m}\tilde{q}_i\tilde{x}_i
		= \eta,
	\end{equation*}
	por lo que concluimos que el algoritmo \ref{algo:inf:ext} es correcto.
\end{proof}

\begin{theorem}
	\label{infinite:th:complexity}
	Sea $\vec{p} \in \R^n$ un vector esencialmente entero tal que su múltiplo coprimo $\vec{q} \in
	\Z^n$ tiene al menos una entrada negativa. Entonces el problema \eqref{theory:formulation} se
	puede resolver a través de encontrar la solución de una ecuación lineal diofantina en $n$
	incógnitas.
\end{theorem}
\begin{proof}
	Como $\vec{q}$ es el múltiplo coprimo de $\vec{p}$, existe un escalar $m$ tal que
	$\vec{p} = m\vec{q}$. Supongamos, sin pérdida de generalidad, que $m$ es positivo. Recuperemos
	$\eta$ del lema \ref{phase-1:lemma:eta}. Por hipótesis, una entrada de $\vec{q}$ es negativa, y
	entonces este vector satisface las condiciones del algoritmo \ref{algo:inf:ext}. Por el teorema
	\ref{th:alg:inf} podemos encontrar, a partir de resolver solo una ecuación lineal diofantina, un
	vector entero no negativo $\vec{x}$ que satisface $\vec{q}^T\vec{x} = \eta$. Observemos que
	\begin{equation*}
		\vec{p}^T\vec{x} = m\vec{q}^T\vec{x} = m\eta.
	\end{equation*}
	Por el corolario \ref{cor:inf:obj} concluimos que $\vec{x}$ no solo es factible para el problema
	\eqref{theory:formulation}, sino que también es un punto óptimo.
\end{proof}

\section{Experimentos numéricos}
\label{sec:inf:exp}
\noindent
En primer lugar, determinamos la complejidad algorítmica del algoritmo \ref{algo:inf:ext} y lo
usamos como base de nuestras comparaciones. En segundo lugar, mostramos que la complejidad del
algoritmo \ref{algo:bb2} en la página \pageref{algo:bb2} depende del número de decimales utilizados
para especificar las entradas del vector objetivo, así como de la magnitud en el lado derecho de las
restricciones. En tercer lugar, diseñamos un experimento numérico que ilustre esta dependencia.

\subsection{Análisis de la complejidad de nuestros algoritmos}
\label{subsec:inf:complex}
\noindent
En ambos algoritmos \ref{algo:inf} y \ref{algo:inf:ext} dados en las páginas \pageref{algo:inf} y
\pageref{algo:inf:ext}, respectivamente, suponemos que el costo de realizar operaciones aritméticas
es constante.

Primero analizamos el algoritmo \ref{algo:inf}. En el ciclo que comienza en la línea
\ref{alg:def:inf:loop} realizamos $\mathcal{O}(n)$ multiplicaciones y $\mathcal{O}(n^2)$ divisiones.
Luego, para $1 \leq i \leq n - 2$, se sigue de la línea \ref{alg:def:inf:g} que calculamos una vez
el máximo común divisor de $n - (i + 1) + 1 = n - i$ números. Vimos en la subsección
\ref{section:number-theory} que el máximo común divisor puede ser definido de manera inductiva.
Entonces calcular el máximo común divisor entre $n - i$ números es equivalente a calcular $n - i$
veces el máximo común divisor entre dos números. Por lo tanto, calculamos
\begin{equation}
	\label{eq:numgcd}
	\sum_{i=1}^{n-2}n - i = n(n - 2) - \frac{(n-2)(n-1)}{2} = \frac{(n-2)(n+1)}{2}
\end{equation}
veces el máximo común divisor entre dos números.

Además, tenemos de las líneas \ref{alg:def:inf:bez} y \ref{alg:def:inf:lastw} que realizamos $n - 1$
llamadas a la subrutina \texttt{Bezout}. Pero habíamos mencionado que los coeficientes de Bézout se
pueden calcular usando el algoritmo extendido de Euclides. Sin embargo, la complejidad de este es un
múltiplo constante de la complejidad del algoritmo de Euclides, el cual calcula el máximo común
divisor entre dos números. Así pues, comparando estas aproximadamente $n$ llamadas a \texttt{Bezout}
con el cálculo de aproximadamente $n^2$ máximos común divisores entre dos números, podemos ignorar las
llamadas a la subrutina \texttt{Bezout}.

En la sección 4.5 de \cite{knuth} se muestra que la complejidad de calcular el máximo común divisor
entre dos enteros $a \leq b$ es $\mathcal{O}(\log_2 b)$. De esta manera, tenemos de las
$\mathcal{O}(n)$ multiplicaciones y $\mathcal{O}(n^2)$ divisiones, así como de \eqref{eq:numgcd} que
la complejidad del algoritmo \ref{algo:inf} es
\begin{equation*}
	\mathcal{O}(n^2\log_2\norm{\vec{q}}_\infty) + \mathcal{O}(n) + \mathcal{O}(n^2) =
	\mathcal{O}(n^2(1 + \log_2\norm{\vec{q}}_\infty)).
\end{equation*}

Del algoritmo \ref{algo:inf:ext} tenemos que las subrutinas \texttt{length} y
\texttt{swap} tienen complejidad constante. Además, recorremos el vector $\vec{q}$ en el ciclo
\ref{alg:inf:loop} una sola vez así como el vector $\tvec{x}$ en el ciclo \ref{alg:inf:loop2}.
Entonces, debido a la única llamada del algoritmo \ref{algo:inf}, este algoritmo también tiene
complejidad cuadrática.

Finalmente, mencionamos que el número de operaciones de estos dos algoritmos dependen exclusivamente de la
dimensión $n$ y no del lado derecho $\eta$ de la ecuación $\vec{q}^T\vec{x} = \eta$. Es decir, la
complejidad de estos algoritmos con respecto a $\eta$ es constante. Los resultados numéricos en la
subsección \ref{subsec:inf:res} confirman esto.

\subsection{Árbol de Ramificación y Acotamiento con profundidad dependiente del número de decimales}
\label{subsec:inf:int}
\noindent
Primero ilustramos a través de un ejemplo que el árbol generado por una implementación pura de R\&A
correspondiente a instancias de \eqref{theory:formulation} tiene profundidad infinita en algunos
casos. Luego mostramos que, aún cuando esta profundidad sea finita, el número de decimales
utilizados para expresar el vector objetivo de \eqref{theory:formulation} afecta exponencialmente en
los tiempos de terminación de este método.

\begin{example}
	\label{ex:inf}
	Consideremos el programa lineal entero
	\begin{align*}
		\max_{(x, y) \in \Z^2} \quad
			& x - y, \\
		\text{s.a.} \quad
			& x - y \leq 0.3, \\
			& x, y \geq 0,
	\end{align*}
	Adoptamos la siguiente convención de notación con respecto a los subproblemas: agregamos un 0
	como sufijo al subíndice si la última restricción añadida fue del tipo $\leq$ y, similarmente,
	agregamos un 1 si la última restricción añadida fue del tipo $\geq$.

	En el lado izquierdo de la figura \ref{fig:infrec} (página \pageref{fig:infrec}) se muestra la
	región factible $S$ del problema relajado asociado. Encontramos que su solución es $(0.3, 0)$.
	Puesto que $0.3$ no es entero, ramificamos sobre esta variable y generamos los subproblemas
	con regiones factibles
	\begin{align*}
		S_0 &\coloneq S \cap \braces{(x, y) \in \R^2 \vcentcolon x \leq 0}, \\
		S_1 &\coloneq S \cap \braces{(x, y) \in \R^2 \vcentcolon x \geq 1}.
	\end{align*}
	La solución del subproblema con región factible $S_{0}$ es $(0, 0)$, así que obtenemos una
	solución incumbente y podamos por cota. Ahora bien, la solución del subproblema con región
	factible $S_{1}$ es $(1, 0.7)$ y como $0.7$ no es entero, generamos los subproblemas con
	regiones factibles
	\begin{align*}
		S_{10} &\coloneq S_1 \cap \braces{(x, y) \in \R^2 \vcentcolon y \leq 0}, \\
		S_{11} &\coloneq S_1 \cap \braces{(x, y) \in \R^2 \vcentcolon y \geq 1}.
	\end{align*}
	Encontramos que el poliedro $S_{10}$ es vacío, así que no ramificamos.

	En el lado derecho de la figura \ref{fig:infrec} se muestra el poliedro $S_{11}$ es una
	traslación de $S$. En otras palabras, $S_{11}$ es un caso particular de una homotecia de $S$.
	Consecuentemente, hay un comportamiento periódico en cuanto a la ramificación y solución de
	estos problemas: resolver el subproblema con región factible $S_{11}$ se reduce a resolver el
	que tiene como región factible a  $S$, pero el primero es un subproblema del segundo. Siguiendo
	este razonamiento, encontramos que R\&A genera una cadena de subproblemas con regiones factibles
	autosimilares
	\begin{equation*}
		S, S_{11}, S_{1111}, S_{111111}, \ldots
	\end{equation*}
	y el algoritmo \ref{algo:bb2} jamás terminará con una solución.
\end{example}

\begin{figure}
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[scale=0.7]
			\begin{axis}[
			  axis lines=middle,
			  xmin=0, xmax=2.2,
			  ymin=0, ymax=2.2,
			  xlabel={$x$}, ylabel={$y$},
			  clip=false
			]
				\addplot [name path=top, draw=none, domain=0:2.2] {2.2};
				\addplot [name path=lower, draw=none, samples=200, domain=0:2.2]
				  {max(x-0.3, 0)};
				\addplot [blue!25] fill between[of=top and lower];
				\addplot [blue, thick, domain=0.3:2.2] {x - 0.3};
				\addplot [blue, thick, domain=0:0.3] {0};
				\node at (axis cs:0.7,1.25) {\Large $S$};
			\end{axis}
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{0.45\textwidth}
		\centering
		\begin{tikzpicture}[scale=0.7, >= stealth]
			\begin{axis}[
			  axis lines=middle,
			  xmin=0, xmax=2.2,
			  ymin=0, ymax=2.2,
			  xlabel={$x$}, ylabel={$y$},
			  clip=false
			]
				\addplot [name path=top, draw=none, domain=1:2.2] {2.2};
				\addplot [name path=lower, draw=none, samples=200, domain=1:2.2]
				  {1 + max(x-1.3, 0)};
				\addplot [blue!25] fill between[of=top and lower];
				\addplot [blue, thick, domain=1.3:2.2] {x - 0.3};
				\addplot [blue, thick, domain=1:1.3] {1};
				\node at (axis cs:1.5,1.7) {\Large $S_{11}$};
			\end{axis}
		\end{tikzpicture}
	\end{minipage}
	\caption{\textit{Izquierda}: Poliedro asociado al problema relajado del ejemplo \ref{ex:inf}.
	\textit{Derecha}: Poliedro asociado a un subproblema de $S$.}
	\label{fig:infrec}
\end{figure}

Observemos que si el lado derecho hubiera sido $0$ en lugar de $0.3$, una implementación pura de
R\&A habría terminado inmediatamente con la solución $(0, 0)$ al resolver el problema relajado. Es
decir, un cambio de $0.3$ unidades en el lado derecho de la única desigualdad provocó que el árbol
generado por R\&A tuviera profundidad unitaria a profundida infinita. Así pues, este ejemplo también
muestra que implementaciones puras de R\&A dependen de la magnitud del lado derecho de las
restricciones.

Sospechamos que el fenómeno presentado en el ejemplo anterior ocurre en todas las instancias de
\eqref{theory:formulation} cuando $\vec{p}$ es esencialmente entero y el lado derecho $u$ de
\eqref{theory:constraint:budget} es tal que $u/m \not\in \Z$, donde $m$ es el escalar que satisface
$\vec{p} = m\vec{q}$, y $\vec{q}$ es el múltiplo coprimo de $\vec{p}$. Es decir, conjeturamos
que, para problemas que cumplen con estas condiciones, existe una colección de subproblemas
homotéticos entre sí. Además, si el múltiplo coprimo $\vec{q}$ de $\vec{p}$ tiene una entrada
negativa, entonces esta colección es infinita. Por cuestiones de longitud de esta tesis de
licenciatura y por el hecho de que es un tema de carácter abierto, no investigamos más en este
respecto.

Para que una implementación pura de R\&A termine en tiempo finito al resolver
una de estas instancias, debe ser el caso que el valor óptimo del problema relajado de
\eqref{theory:formulation} sea el mismo que el de su programa entero. Es decir, tenemos terminación
finita si y solo si el hiperplano definido por
	$\braces{\vec{x} \in \R^n \vcentcolon \vec{p}^T\vec{x} = u}$
contiene un punto entero, donde $u$ es el lado derecho de \eqref{theory:constraint:budget}. Por el
teorema \ref{phase-1:th:cover}, hay terminación finita si y solo si este hiperplano en realidad es
una capa entera $\qlayer{q}{k}$ con parámetro $k \in \Z$.

Supongamos que tenemos terminación finita y que estamos utilizando una implementación pura de R\&A
para resolver una instancia. Por lo discutido anteriormente, todas las soluciones de los
subproblemas se encuentran en la $k$-ésima capa entera. El algoritmo de R\&A genera cortes del
estilo
\begin{equation}
	\label{eq:cuts}
	x_i \leq \big\lfloor x_i^* \big\rfloor,\quad x_i \geq \big\lceil x_i^* \big\rceil,
\end{equation}
donde $\vec{x}^*$ es la solución de un subproblema relajado con $x_i^* \not\in \Z$. Sin pérdida de
generalidad, supongamos que añadimos a este subproblema relajado un corte como el de la derecha de
\eqref{eq:cuts} y que se mantiene la factibilidad. El punto de intersección entre esta restricción
junto con la restricción presupuestaria \eqref{theory:constraint:budget} introduce un único vértice
nuevo para el siguiente subproblema relajado. Tenemos entonces del teorema
\ref{prerreq:th:linear-sol} que este único vértice es una solución. Los algoritmos más comúnes para
resolver problemas relajados siempre encuentran como solución un vértice del poliedro, por lo que
podemos suponer razonablemente que R\&A encontrará este vértice como solución del siguiente
subproblema relajado. Es decir, si $\vec{x}^*$ es solución de un subproblema relajado, entonces
$\big\lceil x_i^* \big\rceil$ constituye la $i$-ésima entrada de la solución del siguiente
subproblema relajado obtenido al añadir el corte $x_i \geq \big\lceil x_i^* \big\rceil$. En
particular, encontramos que
\begin{equation}
	\label{eq:dembound}
	0 <
	\big| x_i^* - \big\lceil x_i^* \big\rceil \big| \leq 1.
\end{equation}

% Ahora bien, por el teorema \ref{th:lattice} sabemos que las columnas de la matriz $M$ definida en
% \eqref{eq:mat-T} son linealmente independientes, por lo que existe $\vec{t}^* \in \R^{n-1}$ tal que
% $\vec{x}^* = k\vec{\nu} + M\vec{t}^*$.

Por el teorema \ref{th:lattice}, existe $(k^*, \vec{t}^*) \in \R^n$ tal que $\vec{x}^* =
k^*\vec{\nu} + M\vec{t}^*$, donde la matriz $M$ y el vector $\vec{\nu}$ están definidos,
respectivamente, en \eqref{eq:vec-omega} y \eqref{eq:mat-T}. Habíamos supuesto que el algoritmo de
R\&A tiene terminación finita, y entonces $\vec{x}^*$ se encuentra en la $k$-ésima capa entera, con
parámetro $k \in \Z$. Se sigue de los lemas \ref{theory:lemma:utility}, \ref{lemma:iso1} y \ref{lemma:iso2}
que
\begin{equation*}
	k = \vec{q}^T\vec{x}^* = k^*\vec{q}^T\vec{\nu} + \left(\vec{q}^TM\right)\vec{t}^* = k^*,
\end{equation*}
y entonces $\vec{x}^* = k\vec{\nu} + M\vec{t}^*$. Sea $\vec{t} \in \Z^{n-1}$ el vector resultante de
redondear las entradas de $\vec{t}^*$ a sus enteros más cercanos. No es difícil ver que $\vec{x}
\coloneq k\vec{\nu} + M\vec{t}$ es un punto entero sobre la $k$-ésima capa entera más cercano a
$\vec{x}^*$. También es cierto que $\vec{t} = \vec{t}^* + \vec{\delta}$ para alguna $\vec{\delta}
\in \R^{n-1}$ que satisface $0 < \norm{\vec{\delta}}_\infty \leq 1/2$. Luego,
\begin{equation}
	\label{eq:numbound}
	\big| x^*_i - x_i \big| =
	\big| \left(\vec{x}^* - \vec{x}\right)_i \big| =
	\big| \vec{e}_i^TM\left(\vec{t}^* - \vec{t}\right) \big| =
	\big| \vec{e}_i^TM\vec{\delta} \big|.
\end{equation}
Dividiendo \eqref{eq:numbound} entre \eqref{eq:dembound} obtenemos
\begin{equation}
	\label{eq:bbound}
	\bigg| \frac{x_i^* - x_i}{x_i^* - \big\lceil x_i^*\big\rceil} \bigg|
	\geq \big|\vec{e}_i^TM\vec{\delta}\big|.
\end{equation}

Entonces el número de decimales utilizados para expresar las entradas del vector objetivo $\vec{p}$
del problema \eqref{theory:formulation} afecta la eficiencia de estos cortes. En efecto, si usamos
un decimal más para especificar las entradas de $\vec{p}$, su vector coprimo $\vec{q}$ se multiplica
aproximadamente por 10. De \eqref{eq:mat-T} tenemos que las entradas de $M$ se multiplican
aproximadamente por 10 y, por lo tanto, el lado derecho de \eqref{eq:bbound} es 10 veces mayor. Es
decir, los cortes de R\&A se vuelven aproximadamente 10 más ineficientes al utilizar un decimal
adicional. En conclusión, la complejidad de Ramificación y Acotamiento es exponencial en el número
de decimales utilizados para expresar $\vec{p}$, pues R\&A requiere 10 veces más cortes por decimal
adicional. No obstante, es cierto que los cortes se vuelven más efectivos una vez que $\vec{x}^*$ se
encuentra cerca de una solución entera, pues $\norm{\vec{\delta}}_\infty \approx 0$.

Como mencionamos en la subsección \ref{subsec:lp}, R\&A encapsula una familia de métodos para
encontrar soluciones de programas lineales enteros. Los resultados hasta ahora obtenidos solamente
aplican para el algoritmo \ref{algo:bb2}, donde contamos con una política de poda y ramificamos
binariamente. Si en el ejemplo \ref{ex:inf} hubiéramos deducido una cota superior más justa que $x -
y \leq 0.3$, R\&A habría encontrado inmediatamente la solución. En efecto, como $(x, y) \in \Z^2$,
se sigue que $x - y \in \Z$ y puesto que $x - y \leq 0.3$, obtenemos la cota superior $x - y \leq
0$. De esta manera, la implementación pura de R\&A falla en este ejemplo particular porque no genera
cortes de Gomory. Redirigimos al lector interesado en esta y otras políticas de poda a la sección 5
del artículo \cite{morrison}.

A pesar de que implementaciones comerciales y de código abierto utilicen otro orden de búsqueda,
ramifiquen de distinta manera, extiendan las políticas de poda, introduzcan heurísticas, preprocesen
el problema, etcétera, veremos en la siguiente subsección que la obtención de soluciones por parte
del \textit{solver} CBC (\cite{coin}) todavía es lenta si comparamos sus tiempos de terminación con
nuestro algoritmo \ref{algo:inf:ext}, o incluso con la cota inferior \eqref{eq:bbound}.
\subsection{Análisis de resultados}
\label{subsec:inf:res}
\noindent
Primero detallamos la manera en la que medimos los resultados de nuestro experimento numérico.
Luego explicamos y justificamos el diseño del experimento. Finalmente mostramos y analizamos los
resultados obtenidos.

Para realizar nuestro experimento numérico con R\&A, usamos el \textit{solver} CBC a través de la
interfaz de PuLP versión 3.1 implementada en Python versión 3.12. Nuestra configuración permite
métodos de preprocesamiento, cortes de mochila y de Gomory-Chvátal. Prohibimos el uso de
múltiples hilos (\textit{threads}) a fin de garantizar una comparación justa con nuestro método.

Cada observación de tiempo representa el promedio de 20 corridas. Para cada observación realizamos 2
corridas preliminares a fin de evitar sesgos en el tiempo por cuestión de temperatura en la
computadora, o por cargar cosas a la memoria, o por compilación al momento de crear archivos
\texttt{.pyc}, etcétera. En total, cada observación es el resultado de haber corrido el mismo
experimento 22 veces.

Por cuestiones de tiempo, cada corrida fue automáticamente terminada si sobrepasaba los 300
segundos. Decimos que el método no encontró una solución si fue automáticamente terminado en más de
10 de las 20 veces que medimos el tiempo de terminación. Para verificar la correctud en la
implementación de nuestro algoritmo, comparamos los valores objetivo de nuestra implementación con
los de CBC y en ningún momento encontramos que fueran distintos. Nuestra implementación se encuentra
libre en GitHub.\footnote{Véase: \url{https://github.com/tempdata73/thesis}}

Finalmente, los experimentos fueron realizados en una computadora portátil Dell XPS 15 equipada con
un procesador Intel Core i7-8750H (6 núcleos físicos y 12 hilos, frecuencia base de 2.20 GHz y
frecuencia máxima de 4.10 GHz). El sistema cuenta con 12 CPU lógicos disponibles y una memoria RAM
de 32 GiB. Todos los cálculos fueron ejecutados bajo la arquitectura x86-64. El sistema operativo
usado fue Fedora Linux 42 (Server Edition).

Inspirados por el hecho de que la implementación pura de R\&A es sensible ante la precisión
numérica, generamos instancias de \eqref{theory:formulation} con dimensión $n = 4$. Este experimento
tiene por objetivo mostrar que los tiempos de terminación de CBC son lentos y aumentan
significativamente cuando utilizamos más cifras decimales para especificar el vector objetivo
$\vec{p}$ de \eqref{theory:formulation}.

Así pues, generamos un vector $\vec{p}_3$ tomado de una distribución uniforme discreta de enteros sobre el
intervalo $[9{,}000, 10{,}000)^n$. A este vector inicial lo dividimos por 1{,}000, de manera que sea
un vector racional con tres cifras decimales y entradas en $[9, 10)$. Escogimos aleatoriamente 2 de
estas $n = 4$ entradas y las multiplicamos por $-1$, con lo que aseguramos que el vector coprimo
$\vec{q}_3$ asociado a $\vec{p}_3$ tenga al menos una entrada negativa.

Luego, muestreamos $n = 4$ observaciones de una distribución uniforme discreta de enteros sobre $[0,
10)$, las multiplicamos por $10^{-4}$ y sumamos cada observación a una entrada de $\vec{p}_3$, de
manera que obtenemos un vector racional $\vec{p}_4$ con cuatro cifras decimales. Repetimos una vez
más el procedimiento anterior pero usando $\vec{p}_4$ para generar el vector racional $\vec{p}_5$
con cinco cifras decimales.

En último lugar, para obtener el lado derecho de \eqref{theory:constraint:budget}, calculamos 128
puntos $u \in \Z_{\geq 0}$ espaciados aproximadamente logarítmicamente en el intervalo $[10^3,
10^7)$. En la figura \ref{fig:exp:inf:rhs} se muestran los tiempos de terminación promedio de las 20
corridas. Las rupturas de continuidad en las líneas son causadas porque CBC no encontró una
solución antes de los 300 segundos.

\begin{figure}[hbtp]
  \centering
  \begin{subfigure}{0.80\textwidth}
    \centering
    \includegraphics[width=\linewidth]{/home/tempdata/repos/thesis/static/inf/digits-bb_full.pdf}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.80\textwidth}
    \centering
    \includegraphics[width=\linewidth]{/home/tempdata/repos/thesis/static/inf/digits-dioph.pdf}
  \end{subfigure}

  \caption{Tiempos de terminación promedio cuando varía el presupuesto y el
	  número de digitos. \textit{Arriba}: Resultados en segundos de R\&A implementado en CBC. \textit{Abajo}:
			Resultados en milisegundos de nuestro método \texttt{dioph}.}
  \label{fig:exp:inf:rhs}
\end{figure}

Por los resultados obtenidos en las dos subsecciones anteriores, no sorprende que el algoritmo
\ref{algo:inf} tenga mejores tiempos de terminación que CBC, y que no se vea afectado por la
precisión numérica del vector objetivo $\vec{p}$. Esto solo muestra que los tiempos de terminación
de CBC son lentos para instancias de \eqref{theory:formulation}.

En realidad nos interesa mostrar la sensibilidad en los tiempos de terminación de CBC a medida que
la precisión del vector objetivo $\vec{p}$ aumenta. Es decir, si $T(\vec{p}_i)$ es el tiempo de
terminación de CBC con una instancia usando el vector esencialmente entero $\vec{p}_i$ que tiene
$i$ cifras decimales, entonces queremos medir la proporción $T(\vec{p}_{i+1}) / T(\vec{p}_i)$.
Llamamos \textbf{multiplicadores} a estas proporciones, pues representan el factor de aumento en
los tiempos de terminación de CBC cuando utilizamos una cifra decimal adicional. Puesto que cada
instancia depende del presupuesto $u$ de la restricción \eqref{theory:constraint:budget} y tomamos
128 de estos presupuestos por cada nivel de precisión $i$, obtenemos a lo más $128 \times (3 - 1) =
256$ multiplicadores registrados, pues no podemos medir aquellos en donde $T(\vec{p}_i)$ es mayor a
300 segundos. La figura \ref{fig:exp:inf:hist} en la página \pageref{fig:exp:inf:hist} muestra la
distribución acumulada de estos multiplicadores. Por cuestiones visuales, juntamos todos los
multiplicadores que fueron mayores a 100 en la última columna.

De acuerdo a la subsección anterior, deberíamos esperar que la gran mayoría de los multiplicadores
se concentren alrededor de 10. Esto último ocurrió en el 40\% de los casos. Después de realizar un
conteo en los archivos de registro generados por CBC, descubrimos que en todos los casos que se
encontró una solución fue a causa de una heurística de redondeo y no por el método de ramificación.
Debido la dificultad del árbol que genera el problema \eqref{theory:formulation}, de acuerdo a la
subsección anterior, esto parece ser razonable.

Aún cuando las soluciones fueron obtenidas exclusivamente a través de heurísticas, en el 60\% de los
casos el multiplicador es mayor a 10. Es decir, una cifra decimal adicional en $\vec{p}$ provoca, en la
mayoría de los casos, que el tiempo de terminación de CBC sea al menos diez veces mayor. Así pues,
los cortes generados por R\&A son más ineficientes de lo que habíamos predicho.

Esperamos que lo realizado en esta sección muestre categóricamente que implementaciones puras
(algoritmo \ref{algo:bb2}) o prácticas (CBC) de Ramificación y Acotamiento no dependen solo del
número de variables o de desigualdades utilizadas, sino que también de la precisión numérica con la
que se especifican los datos. Con esto damos por concluido este capítulo y continuamos con nuestro
desarrollo del segundo caso del teorema \ref{theory:th:feasibility}.

\begin{figure}[hbtp]
  \centering
  \begin{subfigure}{0.80\textwidth}
    \centering
    \includegraphics[width=\linewidth]{/home/tempdata/repos/thesis/static/inf/mult-hist-cum-sep-v2.pdf}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.80\textwidth}
    \centering
    \includegraphics[width=\linewidth]{/home/tempdata/repos/thesis/static/inf/mult-hist-cum-v2.pdf}
  \end{subfigure}

  \caption{Distribución acumulada de los multiplicadores de tiempo. \textit{Arriba:} Separados por
  el número de cifras decimales utilizadas. \textit{Abajo:} Distribución conjunta sin tomar en
	cuenta el número de cifras decimales utilizadas.}
  \label{fig:exp:inf:hist}
\end{figure}
